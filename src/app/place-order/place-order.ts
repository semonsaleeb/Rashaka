import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { ActivatedRoute, Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { ClientService } from '../services/client.service';
import { AddressService } from '../services/address.service';
import { CartService } from '../services/cart.service';
import { CartStateService } from '../services/cart-state-service';
import { CommonModule, DecimalPipe } from '@angular/common';
import { PromoResponse } from '../../models/PromoResponse';
import { PaymentService } from '../services/payment.service';
import { OrderService } from '../services/order.service';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { LanguageService } from '../services/language.service';
import { ProductService } from '../services/product';
import { forkJoin } from 'rxjs';
declare var bootstrap: any;

@Component({
  selector: 'app-place-order',
  templateUrl: './place-order.html',
  styleUrls: ['./place-order.scss'],
  standalone: true,
  imports: [FormsModule, DecimalPipe, TranslateModule, CommonModule]
})
export class PlaceOrder implements OnInit {
  currentLang: string = 'ar';
  token: string = '';
  addresses: any[] = [];
  selectedAddressId: number | null = null;
  paymentMethod: string = 'cash'; // or 'credit_card' / 'free_balance' etc.
  promoCode: string = '';
  userEmail: string = '';
  userPhone: string = '';
  isLoggedIn: boolean = false;
  client: any;
  cartItems: any[] = [];
  totalPrice: number = 0;        // cart_total from API (before offers)
  totalSalePrice: number = 0;    // sale_cart_total from API (after offers)
  addressId: number = 1;
  shippingFee: number = 30;
  freeProductBalance: number = 0;
  discountValue: number = 0;
  dir: 'ltr' | 'rtl' = 'ltr';

  // Free-balance UI
  applyFreeBalance: boolean = false;
  freeBalanceAmount: number = 0;
  totalOrderPrice: number = 0; // optional: used by some UI calc, we keep updated
  maxFreeBalance: number = 0;

  constructor(
    private http: HttpClient,
    private router: Router,
    private clientService: ClientService,
    private addressService: AddressService,
    private cartService: CartService,
    private cartState: CartStateService,
    private route: ActivatedRoute,
    private paymentService: PaymentService,
    private orderService: OrderService,
    private translate: TranslateService,
    private languageService: LanguageService,
    private productService: ProductService,
  ) { }

  // In your payment-success component
ngOnInit(): void {
  // 1Ô∏è‚É£ Token & login
  this.token = localStorage.getItem('token') || '';
  this.isLoggedIn = !!this.token;

  // 2Ô∏è‚É£ Load client/profile/addresses if logged in
  if (this.isLoggedIn) {
    this.loadClientProfile();
    this.fetchAddresses();

    // fetch free product balance
    this.productService.getFreeProductBalance(this.token).subscribe({
      next: (res: any) => {
        this.freeProductBalance = this.toNumber(res?.data?.free_product_remaining ?? 0);
        this.maxFreeBalance = this.freeProductBalance;
        console.log('Remaining Free Product Balance:', this.freeProductBalance);

        // set default free balance (will use current totals)
        this.setDefaultFreeBalanceAmount();
      },
      error: (err) => console.error('‚ùå Error fetching free product balance:', err)
    });
  }

  // 3Ô∏è‚É£ Load cart (use central method)
  this.loadCart();

  // 4Ô∏è‚É£ Check if this is a payment callback (user returning from MyFatoorah)
  const urlParams = new URLSearchParams(window.location.search);
  const orderId = urlParams.get('orderId');
  
  if (orderId) {
    // This is a payment callback - check payment status
    this.cartService.checkPaymentStatus(orderId).subscribe({
      next: (statusRes: any) => {
        if (statusRes.status === 'preparing' || statusRes.status === 'confirmed') {
          // ‚úÖ Payment successful
          this.clearCartAndPendingPayment();
          this.router.navigate(['/order-success', orderId]);
        } else if (statusRes.status === 'pending') {
          // üîµ Still pending - show retry message
          alert('ŸÑŸÖ ÿ™ŸÉÿ™ŸÖŸÑ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ ÿ®ÿπÿØ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
          // Redirect back to checkout page to retry
          this.router.navigate(['/checkout']);
        } else {
          // ‚ùå Payment failed
          this.router.navigate(['/payment-failure'], { 
            queryParams: { orderId, error: statusRes.message } 
          });
        }
      },
      error: (err: any) => {
        console.error('Error checking payment status:', err);
        this.router.navigate(['/payment-failure'], { 
          queryParams: { orderId, error: 'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿØŸÅÿπ' } 
        });
      }
    });
    return; // Stop further execution since we're handling payment callback
  }

  // 5Ô∏è‚É£ Check for normal query params (legacy flow)
  const addressIdParam = this.route.snapshot.queryParamMap.get('addressId');
  const promoCodeParam = this.route.snapshot.queryParamMap.get('promoCode');

  if (addressIdParam) {
    // Legacy flow - confirm order after payment
    this.cartService.placeOrder(+addressIdParam, 'credit_card', promoCodeParam || '', false, 0).subscribe({
      next: (orderRes: any) => {
        console.log('üì¶ Server Response from placeOrder:', orderRes);
        
        // Handle response based on status
        if (orderRes.status === 'success') {
          this.handleSuccessfulOrder(orderRes);
          this.router.navigate(['/order-success', orderRes.data.order_id]);
        } else if (orderRes.status === 'requires_payment_action') {
          this.handleCreditCardPayment(orderRes);
        } else {
          alert('ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠ ÿ®ÿπÿØ ÿßŸÑÿØŸÅÿπ!');
          this.router.navigate(['/order-success', orderRes.order_id]);
        }
      },
      error: (err) => {
        console.error('‚ùå Error confirming order after payment:', err);
        alert('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ∑ŸÑÿ® ÿ®ÿπÿØ ÿßŸÑÿØŸÅÿπ.');
      }
    });
  }

  // 6Ô∏è‚É£ language & dir
  this.currentLang = this.languageService.getCurrentLanguage();
  this.dir = this.currentLang === 'ar' ? 'rtl' : 'ltr';
  this.translate.use(this.currentLang);

  // subscribe lang changes
  this.languageService.currentLang$.subscribe(lang => {
    this.currentLang = lang;
    this.dir = lang === 'ar' ? 'rtl' : 'ltr';
    this.translate.use(lang);
  });
}

  // ========================= Utilities =========================
  private getHeaders() {
    return new HttpHeaders({
      'Accept': 'application/json',
      'Authorization': `Bearer ${this.token}`
    });
  }

  private toNumber(value: any): number {
    if (value === null || value === undefined) return 0;
    // remove commas if string and convert
    const s = String(value).replace(/,/g, '');
    const n = Number(s);
    return isNaN(n) ? 0 : n;
  }

  private round2(n: number): number {
    return Math.round((n + Number.EPSILON) * 100) / 100;
  }

  // update totals state from API cartData object
  private updateTotalsFromApi(cartData: any) {
    this.cartItems = (cartData.items || []).map((item: any) => {
      const unitPrice = this.toNumber(item.unit_price);
      const saleUnitPrice = item.sale_unit_price != null ? this.toNumber(item.sale_unit_price) : null;
      return {
        ...item,
        unit_price: unitPrice,
        sale_unit_price: saleUnitPrice,
        total_price: this.toNumber(item.total_price) || unitPrice * (item.quantity || 1),
        total_price_after_offers: this.toNumber(item.total_price_after_offers) || (saleUnitPrice || unitPrice) * (item.quantity || 1)
      };
    });

    // totals from backend (preferred)
    this.totalPrice = this.toNumber(cartData.cart_total);
    this.totalSalePrice = this.toNumber(cartData.sale_cart_total);
    this.discountValue = this.toNumber(cartData.discount_value);

    // update other values if provided
    if (cartData.remaining_free_balance !== undefined) {
      this.freeProductBalance = this.toNumber(cartData.remaining_free_balance);
    }

    // update cart count
    const totalQuantity = this.cartItems.reduce((sum, item) => sum + (item.quantity || 0), 0);
    this.cartState.updateCount(totalQuantity);

    // update UI helpers
    this.totalOrderPrice = this.totalSalePrice - this.discountValue;
    this.maxFreeBalance = Math.min(this.freeProductBalance, this.totalOrderPrice);
    // ensure freeBalanceAmount does not exceed new max
    if (this.freeBalanceAmount > this.maxFreeBalance) this.freeBalanceAmount = this.maxFreeBalance;
  }

  // ========================= Cart load =========================
  loadCart() {
    this.cartService.getCart().subscribe({
      next: (response: any) => {
        console.log('üì¶ Full Cart API Response:', response);
        const cartData = response?.data;
        if (!cartData || !Array.isArray(cartData.items)) {
          console.warn('Cart data is empty or invalid');
          this.cartItems = [];
          this.totalPrice = 0;
          this.totalSalePrice = 0;
          this.discountValue = 0;
          this.cartState.updateCount(0);
          return;
        }

        // Use backend-provided totals (no manual calc)
        this.updateTotalsFromApi(cartData);

        console.log('Cart Totals from API:', {
          total: this.totalPrice,
          saleTotal: this.totalSalePrice,
          discount: this.discountValue,
          shippingFee: this.shippingFee,
          freeProductBalance: this.freeProductBalance,
          freeBalanceApplied: this.freeBalanceAmount
        });
      },
      error: (err) => {
        console.error('‚ùå Error loading cart', err);
      }
    });
  }

  // ========================= Promo =========================
  applyPromoCode() {
    const headers = this.getHeaders();
    const body = {
      promocode: this.promoCode,
      total_price: this.totalPrice
    };

    this.http.post<PromoResponse>(`${environment.apiBaseUrl}/order/apply-promocode`, body, { headers })
      .subscribe({
        next: (res: any) => {
          if (res && res.success) {
            // use toNumber in case API returns string
            this.totalSalePrice = this.toNumber(res.new_total);
            // discountValue might be returned; update if available
            if (res.discount_value !== undefined) {
              this.discountValue = this.toNumber(res.discount_value);
            }
            alert(`ÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÉŸàÿØ: ${res.promocode || this.promoCode}`);
          } else {
            alert('ÿ±ŸÖÿ≤ ÿßŸÑÿÆÿµŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠');
          }
        },
        error: (err) => {
          console.error('Promo error:', err);
          alert('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÉŸàÿØ');
        }
      });
  }

  // ========================= Client & Addresses =========================
  loadClientProfile() {
    this.clientService.getProfile().subscribe({
      next: (res: any) => {
        this.client = res.client;
        console.log('‚úÖ Client loaded:', this.client);
        this.userEmail = this.client?.email || '';
        this.userPhone = this.client?.phone || '';
      },
      error: (err) => {
        console.error('‚ùå Failed to load client profile:', err);
      }
    });
  }

  fetchAddresses() {
    this.addressService.getAllAddresses().subscribe({
      next: (res: any) => {
        console.log('Addresses API response:', res);
        this.addresses = res.data || res || [];
        if (this.addresses.length > 0) {
          this.selectedAddressId = this.addresses[0].id;
        }
      },
      error: () => {
        alert('ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ');
      }
    });
  }

  onAddressChange() {
    const selectedAddr = this.addresses.find(addr => addr.id === this.selectedAddressId);
    if (selectedAddr) {
      this.shippingFee = this.toNumber(selectedAddr.fee || 0);
    }

    if (!this.selectedAddressId) {
      alert('ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßÿÆÿ™ÿ± ÿπŸÜŸàÿßŸÜ ÿ¥ÿ≠ŸÜ');
    }
  }

  navigateToAddAddress() {
    this.router.navigate(['/profile/addresses']);
  }

// ========================= Place order =========================
placeOrder(): void {
  // ‚úÖ ÿßŸÑŸÅÿßŸÑŸäÿØŸäÿ¥ŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
  if (!this.client || !this.client.id) {
    console.error('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÖŸäŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©');
    alert('ÿÆÿ∑ÿ£ ŸÅŸä ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÖŸäŸÑÿå Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ');
    return;
  }

  if (!this.selectedAddressId) {
    console.error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ¥ÿ≠ŸÜ');
    alert('ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßÿÆÿ™ÿ± ÿπŸÜŸàÿßŸÜ ÿ¥ÿ≠ŸÜ ÿµÿßŸÑÿ≠');
    return;
  }

  if (!this.paymentMethod) {
    console.error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿØŸÅÿπ');
    alert('ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßÿÆÿ™ÿ± ÿ∑ÿ±ŸäŸÇÿ© ÿØŸÅÿπ ÿµÿßŸÑÿ≠ÿ©');
    return;
  }

  if (!this.cartItems || this.cartItems.length === 0) {
    console.error('ÿßŸÑÿ≥ŸÑÿ© ŸÅÿßÿ±ÿ∫ÿ©');
    alert('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÅŸä ÿ≥ŸÑÿ© ÿßŸÑÿ™ÿ≥ŸàŸÇ');
    return;
  }

  if (!navigator.onLine) {
    console.error('ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™');
    alert('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿßÿØŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™');
    return;
  }

  // üîπ ÿ≠ÿ≥ÿßÿ® free balance
  let freeBalanceToApply = 0;
  if (this.applyFreeBalance && this.freeProductBalance > 0) {
    const base = this.totalSalePrice - this.discountValue;
    const totalCartPrice = Math.max(0, base);
    freeBalanceToApply = Math.min(
      this.freeBalanceAmount || totalCartPrice,
      this.freeProductBalance,
      totalCartPrice
    );
  }

  // üîπ ÿßÿ≥ÿ™ÿØÿπÿßÿ° placeOrder ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠
  this.cartService.placeOrder(
    this.selectedAddressId,
    this.paymentMethod,
    this.promoCode,
    this.applyFreeBalance,
    freeBalanceToApply
  ).subscribe({
    next: (orderRes: any) => {
      console.log('üì¶ ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÖŸÜ placeOrder:', orderRes);

      if (orderRes.status === 'success') {
        this.handleSuccessfulOrder(orderRes);
        this.router.navigate(['/order-success', orderRes.data.order_id]);
      } else if (orderRes.status === 'requires_payment_action') {
        if (orderRes.data.payment_url) {
          this.handleCreditCardPayment(orderRes);
        } else {
          console.error('No payment URL provided');
          alert('ÿÆÿ∑ÿ£ ŸÅŸä ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿØŸÅÿπ');
        }
      } else if (orderRes.status === 'error') {
        alert(orderRes.message || 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®');
      }
    },
    error: (err) => {
      console.error('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®:', err);
      this.handleOrderError(err);
    }
  });
}



// Add these methods to your PlaceOrder class

private handleSuccessfulOrder(orderRes: any): void {
  // Clear cart and reset values
  this.cartState.clearCart();
  localStorage.removeItem('cart');
  this.freeBalanceAmount = 0;
  this.promoCode = '';
  this.applyFreeBalance = false;
  
  console.log('‚úÖ Order completed successfully:', orderRes);
}

private clearCartAndPendingPayment(): void {
  // Clear cart
  this.cartState.clearCart();
  localStorage.removeItem('cart');
  
  // Clear pending payment data
  localStorage.removeItem('pendingPayment');
  
  // Reset form values
  this.freeBalanceAmount = 0;
  this.promoCode = '';
  this.applyFreeBalance = false;
}

// ========================= Payment handlers =========================
private handleCreditCardPayment(orderRes: any): void {
  try {
    // Store pending payment info
    localStorage.setItem(
      'pendingPayment',
      JSON.stringify({ 
        orderId: orderRes.data.order_id, 
        invoiceId: orderRes.data.invoice_id 
      })
    );

    // Redirect to MyFatoorah payment page
    window.location.href = orderRes.data.payment_url;
    
  } catch (e) {
    console.error('ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ:', e);
    alert('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ');
  }
}



private handleCashPayment(orderRes: any): void {
  if (!orderRes.order_id) {
    console.error('ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ± ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©:', orderRes);
    alert('ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπÿ© ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ');
    return;
  }

  this.orderService.updateOrderStatus(orderRes.order_id, 'shipped').subscribe({
    next: (res) => {
      console.log('‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ® ÿ•ŸÑŸâ ÿ¥ÿ≠ŸÜ:', res);

      // üü¢ ŸÅÿ∂Ÿä ÿßŸÑŸÉÿßÿ±ÿ™ ÿ®ÿπÿØ ÿßŸÑÿØŸÅÿπ ÿßŸÑŸÉÿßÿ¥
      this.cartState.clearCart();
      localStorage.removeItem('cart');
      this.freeBalanceAmount = 0;
      this.promoCode = '';
      this.applyFreeBalance = false;

      // show modal
      const modalEl = document.getElementById('cashOrderModal');
      if (modalEl) {
        const modal = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
        modal.show();
      } else {
        this.router.navigate(['/order-success', orderRes.order_id]);
      }
    },
    error: (err) => {
      console.error('‚ùå ŸÅÿ¥ŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®:', err);
      alert('ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ∑ŸÑÿ® ŸàŸÑŸÉŸÜ ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿßŸÑÿ©.');
      this.router.navigate(['/order-success', orderRes.order_id]).catch(e => console.error(e));
    }
  });
}

  goHome() {
    const modalEl = document.getElementById('cashOrderModal');
    const modalInstance = modalEl ? bootstrap.Modal.getInstance(modalEl) : null;
    if (modalInstance) modalInstance.hide();
    this.router.navigate(['/']);
  }

  goOrders() {
    const modalEl = document.getElementById('cashOrderModal');
    const modalInstance = modalEl ? bootstrap.Modal.getInstance(modalEl) : null;
    if (modalInstance) modalInstance.hide();
    this.router.navigate(['/profile/orders']);
  }

  // ========================= Cancel order / clear cart =========================
  openCancelModal() {
    const modalEl = document.getElementById('cancelOrderModal');
    if (modalEl) {
      const modal = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
      modal.show();
    }
  }

  confirmCancelOrder() {
    const token = localStorage.getItem('token');

    if (token) {
      // Logged-in user ‚Üí remove all items via API
      this.cartService.getCart().subscribe({
        next: (res: any) => {
          const items = res.data?.items || [];
          const removeRequests = items.map((item: any) => this.cartService.removeCartItem(item.product_id));
          forkJoin(removeRequests).subscribe({
            next: () => {
              this.cartState.clearCart();
              this.router.navigate(['/']);
            },
            error: (err) => console.error('Error removing items:', err)
          });
        },
        error: (err) => console.error('Error fetching cart:', err)
      });
    } else {
      // Guest user ‚Üí clear localStorage
      this.cartService.clearGuestCart();
      this.cartState.clearCart();
      this.router.navigate(['/']);
    }

    const modalEl = document.getElementById('cancelOrderModal');
    const modalInstance = modalEl ? bootstrap.Modal.getInstance(modalEl) : null;
    if (modalInstance) modalInstance.hide();
  }

  cancelOrder(): void {
    this.openCancelModal();
  }

  // ========================= Free balance helpers =========================
calculateMaxFreeBalance() {
  // ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä: ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ≥ÿπÿ± ÿ®ÿπÿØ ÿßŸÑÿÆÿµŸÖ + ÿßŸÑÿ¥ÿ≠ŸÜ
  const base = Math.max(0, this.totalSalePrice);

  // ŸÑŸà freeProductBalance ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿßŸÑÿ≥ÿπÿ±ÿå ŸÜÿÆŸÑŸä ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸáŸà ÿßŸÑÿ≥ÿπÿ± (base)
  // ŸÑŸà freeProductBalance ÿ£ÿµÿ∫ÿ± ŸÖŸÜ ÿßŸÑÿ≥ÿπÿ±ÿå ŸÜÿÆŸÑŸä ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸáŸà freeProductBalance
  this.maxFreeBalance = this.freeProductBalance >= base ? base : this.freeProductBalance;

  // ŸÑŸà ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÑŸä ŸÖÿØÿÆŸÑÿ© ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®ŸäŸáÿå ŸÜÿ±ÿ¨ÿπŸáÿß ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ
  if (this.freeBalanceAmount > this.maxFreeBalance) {
    this.freeBalanceAmount = this.maxFreeBalance;
  }
}


  onFreeBalanceToggle() {
    if (!this.applyFreeBalance) {
      this.freeBalanceAmount = 0;
    } else {
      this.calculateMaxFreeBalance();
    }
  }

  setDefaultFreeBalanceAmount() {
    const total = Math.max(0, this.totalSalePrice  - this.discountValue);
    this.freeBalanceAmount = Math.min(total, this.freeProductBalance);
  }

  onFreeBalanceRadioSelect() {
    if (this.paymentMethod === 'free_balance') {
      this.calculateMaxFreeBalance();
      this.freeBalanceAmount = Math.min(this.maxFreeBalance, this.freeProductBalance);
    } else {
      this.freeBalanceAmount = 0;
    }
  }

  validateFreeBalance() {
    if (this.freeBalanceAmount > this.maxFreeBalance) {
      this.freeBalanceAmount = this.maxFreeBalance;
    } else if (this.freeBalanceAmount < 0) {
      this.freeBalanceAmount = 0;
    }
  }

  incrementFreeBalance() {
    if (this.freeBalanceAmount < this.maxFreeBalance) {
      this.freeBalanceAmount = this.round2(this.freeBalanceAmount + 1);
    }
  }

  decrementFreeBalance() {
    if (this.freeBalanceAmount > 0) {
      this.freeBalanceAmount = this.round2(this.freeBalanceAmount - 1);
    }
  }

  get remainingBalance(): number {
    return this.round2(this.freeProductBalance - this.freeBalanceAmount);
  }

  get grandTotal(): number {
    // total after offers + shipping - free balance applied - discount (discount already applied in totalSalePrice if backend returns it)
    // Use: sale total + shipping - discountValue - freeBalanceAmount
    const base = this.totalSalePrice - this.discountValue;
    const afterFree = base - (this.applyFreeBalance ? this.freeBalanceAmount : 0);
    return this.round2(afterFree > 0 ? afterFree : 0);
  }

  // ========================= Error handlers =========================
  private handleOrderError(err: any): void {
    let errorMessage = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ™ŸÖÿßŸÖ ÿßŸÑÿ∑ŸÑÿ®';

    if (err.status === 0) {
      errorMessage = 'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿßÿØŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™';
    } else if (err.status === 400) {
      errorMessage = 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©';
    } else if (err.status === 401) {
      errorMessage = 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ÿ®ÿßŸÑŸàÿµŸàŸÑÿå Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ';
    } else if (err.status === 404) {
      errorMessage = 'ÿßŸÑÿÆÿØŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã';
    } else if (err.status === 500) {
      errorMessage = 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿÆÿßÿØŸÖ ÿßŸÑÿØÿßÿÆŸÑŸä';
    } else if (err.error?.message) {
      errorMessage = err.error.message;
    } else if (err.message) {
      errorMessage = err.message;
    }

    console.error('ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£:', {
      status: err.status,
      message: err.message,
      error: err.error,
      url: err.url
    });

    alert(errorMessage);
  }

  private handlePaymentError(err: any): void {
    let errorMessage = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ';

    if (err.status === 0) {
      errorMessage = 'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿÆÿØŸÖÿ© ÿßŸÑÿØŸÅÿπ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™';
    } else if (err.status === 400) {
      errorMessage = 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØŸÅÿπ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©';
    } else if (err.status === 401) {
      errorMessage = 'ŸÖŸÅÿ™ÿßÿ≠ API ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ ŸÑÿÆÿØŸÖÿ© ÿßŸÑÿØŸÅÿπ';
    } else if (err.error?.Message) {
      errorMessage = err.error.Message;
    } else if (err.error?.message) {
      errorMessage = err.error.message;
    }

    console.error('ÿ™ŸÅÿßÿµŸäŸÑ ÿÆÿ∑ÿ£ ÿßŸÑÿØŸÅÿπ:', {
      status: err.status,
      message: err.message,
      error: err.error,
      url: err.url
    });

    alert(errorMessage);
  }

  private decodeToken(token: string): any {
    try {
      const payload = token.split('.')[1];
      const decodedPayload = atob(payload);
      return JSON.parse(decodedPayload);
    } catch {
      return null;
    }
  }
}
